### Project scaffold for Bluestron with Spring Boot 3, Next.js (TypeScript), and Postgres

You’re building an enterprise‑friendly, production‑ready system with minimal dependencies, strict schema control, and block‑by‑block verification. Below is a super‑prompt and the complete first dependent block—Categories—implemented end‑to‑end (DB schema + seed + Java backend + Next.js UI + verification via curl). Once Categories are verified, we’ll stack Courses on top.

---

## Super prompt to generate the app in dependent blocks

Use this prompt to drive each block (Categories → Courses → Registrations → Services → Blog → etc.). It enforces contract‑first, reproducible scaffolding, and verification loops.

> Build Bluestron as a monorepo with:
> - Backend: Spring Boot 3.x (Java 17), minimal dependencies (Spring Web, Spring Data JPA, PostgreSQL driver, validation), package `co.ke.bluestron`.
> - Frontend: Next.js latest with TypeScript, App Router, strict ESLint/Prettier, server components where appropriate, client components for forms, Tailwind optional.
> - Database: Postgres with schema migrations using SQL files (`IF NOT EXISTS`) and a Makefile to run commands (create schema, apply migrations, seed data).
> - Architecture: Contract‑first. Each block includes DB schema, seed, backend endpoints, DTOs, validation, UI pages/components, and verification (curl + UI).
> - Constraints: Enterprise‑friendly, minimal dependencies, explicit file paths, comments explaining intent, reproducible commands, no hidden magic.
> - Verification: Provide curl commands and UI steps to confirm functionality before moving to the next block.
> - Blocks: Start with Categories (since Courses depend on Categories). After Categories are verified, implement Courses fully (schema + seed + backend + UI + verification), then Registration, then Services pages, then Blog.
> - Output: Full code with file paths, brief allegorical comments that summarize how each piece works, and Makefile targets to run everything.

---

## Monorepo structure

```
bluestron/
├─ backend/
│  ├─ src/main/java/co/ke/bluestron/...
│  ├─ src/main/resources/application.yml
│  ├─ build.gradle
│  ├─ settings.gradle
│  ├─ migrations/
│  │  ├─ 001_init_schema.sql
│  │  ├─ 002_categories_table.sql
│  │  └─ 003_seed_categories.sql
├─ frontend/
│  ├─ app/...
│  ├─ components/...
│  ├─ lib/...
│  ├─ package.json
│  ├─ tsconfig.json
│  ├─ next.config.js
├─ Makefile
├─ README.md
```

---

## Block 1: Categories (end‑to‑end)

### Backend—Gradle and configuration

##### backend/build.gradle
```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.3.2'
    id 'io.spring.dependency-management' version '1.1.5'
}

group = 'co.ke.bluestron'
version = '0.0.1'
java {
    toolchain { languageVersion = JavaLanguageVersion.of(17) }
}

repositories { mavenCentral() }

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.postgresql:postgresql:42.7.3'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.test { useJUnitPlatform() }
```

##### backend/settings.gradle
```gradle
rootProject.name = 'bluestron-backend'
```

##### backend/src/main/resources/application.yml
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bluestron
    username: bluestron
    password: bluestron
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format_sql: true
        show_sql: false
  mvc:
    problemdetails:
      enabled: true

server:
  port: 8080
```

##### backend/src/main/java/co/ke/bluestron/BluestronApplication.java
```java
package co.ke.bluestron;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// Allegory: This is the conductor—boots the orchestra and keeps timing tight.
@SpringBootApplication
public class BluestronApplication {
    public static void main(String[] args) {
        SpringApplication.run(BluestronApplication.class, args);
    }
}
```

---

### Database—schema, table, seed (IF NOT EXISTS)

##### backend/migrations/001_init_schema.sql
```sql
-- Allegory: We lay the foundation—rooms (schemas) before furniture (tables).
CREATE SCHEMA IF NOT EXISTS bluestron;
SET search_path TO bluestron;
```

##### backend/migrations/002_categories_table.sql
```sql
SET search_path TO bluestron;

-- Allegory: A catalog shelf—each category is a labeled section.
CREATE TABLE IF NOT EXISTS categories (
  id          BIGSERIAL PRIMARY KEY,
  slug        TEXT UNIQUE NOT NULL,
  name        TEXT NOT NULL,
  description TEXT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_categories_slug ON categories(slug);
CREATE INDEX IF NOT EXISTS idx_categories_name ON categories(name);
```

##### backend/migrations/003_seed_categories.sql
```sql
SET search_path TO bluestron;

-- Allegory: Stock the shelves with familiar sections.
INSERT INTO categories (slug, name, description)
VALUES
  ('project-management-me', 'Project Management & M&E', 'Courses on PM, M&E, evaluations, USAID rules'),
  ('data-management-analysis', 'Data Management & Analysis', 'Excel, Power BI, SPSS, Stata, R, SAS, CSPro, cybersecurity'),
  ('gis-it', 'GIS & IT / Mobile Data Collection', 'GIS in M&E, spatial analysis, mobile data collection'),
  ('management-hr', 'Management & Administration / HR', 'HR planning, BPM, supervisory skills, communication'),
  ('climate-environment', 'Climate Change / Environment', 'Climate finance, ESG, environmental safeguards')
ON CONFLICT (slug) DO NOTHING;
```

---

### Makefile—commands to run DB and backend

##### Makefile
```make
# Allegory: One baton to cue the band—consistent commands, no guesswork.

DB_NAME=bluestron
DB_USER=bluestron
DB_PASS=bluestron
DB_HOST=localhost
DB_PORT=5432

.PHONY: db-create db-user db-migrate db-seed backend-run backend-build frontend-dev frontend-build verify-categories

db-create:
	@echo "Creating database $(DB_NAME)"
	-psql -h $(DB_HOST) -U postgres -c "CREATE DATABASE $(DB_NAME);"
	@echo "Ensuring schema exists"
	psql -h $(DB_HOST) -U postgres -d $(DB_NAME) -f backend/migrations/001_init_schema.sql

db-user:
	@echo "Creating user $(DB_USER) with password"
	-psql -h $(DB_HOST) -U postgres -c "CREATE USER $(DB_USER) WITH PASSWORD '$(DB_PASS)';"
	-psql -h $(DB_HOST) -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE $(DB_NAME) TO $(DB_USER);"

db-migrate:
	@echo "Applying migrations"
	psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f backend/migrations/001_init_schema.sql
	psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f backend/migrations/002_categories_table.sql

db-seed:
	@echo "Seeding categories"
	psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f backend/migrations/003_seed_categories.sql

backend-run:
	@echo "Starting Spring Boot backend"
	cd backend && ./gradlew bootRun

backend-build:
	cd backend && ./gradlew clean build

frontend-dev:
	cd frontend && npm run dev

frontend-build:
	cd frontend && npm run build

verify-categories:
	@echo "Verifying categories endpoint"
	curl -s http://localhost:8080/api/categories | jq '.'
```

> Tip: Ensure Postgres is running and you can `psql -U postgres`. If you prefer Docker, we can add a `docker-compose.yml` later—keeping dependencies minimal for now.

---

### Backend—domain, repository, service, controller, DTOs

##### backend/src/main/java/co/ke/bluestron/categories/Category.java
```java
package co.ke.bluestron.categories;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

// Allegory: The shelf record—simple, sturdy, and indexed.
@Entity
@Table(name = "categories", schema = "bluestron")
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String slug;

    @Column(nullable = false)
    private String name;

    @Column
    private String description;

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;

    @PrePersist
    public void onCreate() {
        OffsetDateTime now = OffsetDateTime.now();
        this.createdAt = now;
        this.updatedAt = now;
    }

    @PreUpdate
    public void onUpdate() {
        this.updatedAt = OffsetDateTime.now();
    }

    // Getters and setters omitted for brevity
    // ... generate via IDE or Lombok (we avoid Lombok to keep dependencies minimal)
    public Long getId() { return id; }
    public String getSlug() { return slug; }
    public void setSlug(String slug) { this.slug = slug; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public OffsetDateTime getCreatedAt() { return createdAt; }
    public OffsetDateTime getUpdatedAt() { return updatedAt; }
}
```

##### backend/src/main/java/co/ke/bluestron/categories/CategoryRepository.java
```java
package co.ke.bluestron.categories;

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

// Allegory: The librarian—finds books by label or title.
public interface CategoryRepository extends JpaRepository<Category, Long> {
    Optional<Category> findBySlug(String slug);
    boolean existsBySlug(String slug);
}
```

##### backend/src/main/java/co/ke/bluestron/categories/CategoryDTO.java
```java
package co.ke.bluestron.categories;

import jakarta.validation.constraints.NotBlank;

// Allegory: The index card—clean, minimal, and validated.
public record CategoryDTO(
        @NotBlank String slug,
        @NotBlank String name,
        String description
) {}
```

##### backend/src/main/java/co/ke/bluestron/categories/CategoryResponse.java
```java
package co.ke.bluestron.categories;

// Allegory: The public catalog entry—what the world sees.
public record CategoryResponse(
        Long id,
        String slug,
        String name,
        String description
) {
    public static CategoryResponse from(Category c) {
        return new CategoryResponse(c.getId(), c.getSlug(), c.getName(), c.getDescription());
    }
}
```

##### backend/src/main/java/co/ke/bluestron/categories/CategoryService.java
```java
package co.ke.bluestron.categories;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

// Allegory: The curator—ensures shelves stay consistent and tidy.
@Service
public class CategoryService {

    private final CategoryRepository repo;

    public CategoryService(CategoryRepository repo) {
        this.repo = repo;
    }

    @Transactional(readOnly = true)
    public List<CategoryResponse> list() {
        return repo.findAll().stream().map(CategoryResponse::from).toList();
    }

    @Transactional
    public CategoryResponse create(CategoryDTO dto) {
        if (repo.existsBySlug(dto.slug())) {
            throw new IllegalArgumentException("Category slug already exists: " + dto.slug());
        }
        Category c = new Category();
        c.setSlug(dto.slug());
        c.setName(dto.name());
        c.setDescription(dto.description());
        Category saved = repo.save(c);
        return CategoryResponse.from(saved);
    }

    @Transactional(readOnly = true)
    public CategoryResponse getBySlug(String slug) {
        Category c = repo.findBySlug(slug).orElseThrow(() -> new IllegalArgumentException("Not found: " + slug));
        return CategoryResponse.from(c);
    }
}
```

##### backend/src/main/java/co/ke/bluestron/categories/CategoryController.java
```java
package co.ke.bluestron.categories;

import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

// Allegory: The front desk—welcomes requests and hands back neat answers.
@RestController
@RequestMapping("/api/categories")
public class CategoryController {

    private final CategoryService service;

    public CategoryController(CategoryService service) {
        this.service = service;
    }

    @GetMapping
    public ResponseEntity<List<CategoryResponse>> list() {
        return ResponseEntity.ok(service.list());
    }

    @GetMapping("/{slug}")
    public ResponseEntity<CategoryResponse> get(@PathVariable String slug) {
        return ResponseEntity.ok(service.getBySlug(slug));
    }

    @PostMapping
    public ResponseEntity<CategoryResponse> create(@Valid @RequestBody CategoryDTO dto) {
        return ResponseEntity.ok(service.create(dto));
    }
}
```

---

### Frontend—Next.js (TypeScript) with App Router

##### frontend/package.json
```json
{
  "name": "bluestron-frontend",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.2.5",
    "react": "18.2.0",
    "react-dom": "18.2.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.30",
    "@types/react": "^18.2.66",
    "typescript": "^5.6.2",
    "eslint": "^8.57.0",
    "eslint-config-next": "^14.2.5"
  }
}
```

##### frontend/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": { "@/*": ["./*"] }
  }
}
```

##### frontend/next.config.js
```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: { serverActions: true }
};
module.exports = nextConfig;
```

##### frontend/app/layout.tsx
```tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  // Allegory: The gallery frame—consistent chrome around every exhibit.
  return (
    <html lang="en">
      <body style={{ margin: 0, fontFamily: 'system-ui, sans-serif' }}>
        <header style={{ padding: '1rem', borderBottom: '1px solid #eee' }}>
          <nav style={{ display: 'flex', gap: '1rem' }}>
            <a href="/">Home</a>
            <a href="/courses">Courses</a>
            <a href="/services">Services</a>
            <a href="/contact">Contact</a>
          </nav>
        </header>
        <main style={{ padding: '1rem' }}>{children}</main>
        <footer style={{ padding: '1rem', borderTop: '1px solid #eee' }}>
          <small>© Bluestron</small>
        </footer>
      </body>
    </html>
  );
}
```

##### frontend/lib/api.ts
```ts
// Allegory: A polite courier—fetches data and returns it cleanly.
const BASE_URL = process.env.NEXT_PUBLIC_API_URL ?? 'http://localhost:8080';

export async function fetchCategories() {
  const res = await fetch(`${BASE_URL}/api/categories`, { cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to fetch categories');
  return res.json() as Promise<Array<{ id: number; slug: string; name: string; description: string | null }>>;
}

export async function fetchCategory(slug: string) {
  const res = await fetch(`${BASE_URL}/api/categories/${slug}`, { cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to fetch category');
  return res.json() as Promise<{ id: number; slug: string; name: string; description: string | null }>;
}
```

##### frontend/app/page.tsx (Home)
```tsx
import { fetchCategories } from '@/lib/api';

export default async function HomePage() {
  const categories = await fetchCategories();
  // Allegory: The foyer—quick glance at the wings of the museum.
  return (
    <section>
      <h1>Bluestron Training</h1>
      <p>Professional Training, Research & Software Development in Data, M&E, Management</p>
      <h2>Categories</h2>
      <ul>
        {categories.map((c) => (
          <li key={c.id}>
            <a href={`/courses?category=${encodeURIComponent(c.slug)}`}>{c.name}</a> — {c.description}
          </li>
        ))}
      </ul>
    </section>
  );
}
```

##### frontend/app/courses/page.tsx
```tsx
import { fetchCategories } from '@/lib/api';

export default async function CoursesPage({ searchParams }: { searchParams?: { category?: string } }) {
  const categories = await fetchCategories();
  const selected = searchParams?.category;

  // Allegory: The catalog room—filters on the left, listings on the right (courses later).
  return (
    <div style={{ display: 'grid', gridTemplateColumns: '240px 1fr', gap: '1rem' }}>
      <aside>
        <h3>Categories</h3>
        <ul>
          {categories.map((c) => (
            <li key={c.id}>
              <a href={`/courses?category=${encodeURIComponent(c.slug)}`}>{c.name}</a>
            </li>
          ))}
        </ul>
      </aside>
      <section>
        <h2>Courses</h2>
        {!selected ? (
          <p>Select a category to view courses.</p>
        ) : (
          <p>Selected category: <strong>{selected}</strong> — courses will appear here in Block 2.</p>
        )}
      </section>
    </div>
  );
}
```

##### frontend/components/CategoryBadge.tsx
```tsx
// Allegory: A neat label—small, readable, and clickable.
export function CategoryBadge({ name }: { name: string }) {
  return (
    <span style={{ padding: '0.25rem 0.5rem', border: '1px solid #ddd', borderRadius: '999px' }}>
      {name}
    </span>
  );
}
```

---

## Verification loop for Categories

1. **Create DB and user, apply migrations, seed:**
   ```
   make db-user
   make db-create
   make db-migrate
   make db-seed
   ```

2. **Run backend:**
   ```
   make backend-run
   ```

3. **Verify via curl:**
   ```
   make verify-categories
   # or
   curl -s http://localhost:8080/api/categories | jq '.'
   curl -s http://localhost:8080/api/categories/project-management-me | jq '.'
   ```

4. **Run frontend:**
   ```
   cd frontend && npm install
   make frontend-dev
   ```
   - Visit `http://localhost:3000` → Home shows categories.
   - Visit `http://localhost:3000/courses?category=project-management-me` → filter reflects selection.

5. **Create a new category (POST):**
   ```
   curl -X POST http://localhost:8080/api/categories \
     -H "Content-Type: application/json" \
     -d '{"slug":"test-category","name":"Test Category","description":"For verification"}'
   ```

---

## Block 2 preview: Courses (dependent on Categories)

Once Categories are verified, we’ll add:

- `courses` table with FK to `categories(id)`, `IF NOT EXISTS` migration + seed.
- Backend: `Course` entity, repository, DTOs, service, controller (`/api/courses`, `/api/courses?category=slug`).
- Frontend: Course listing under selected category, course detail page, “Register” button.
- Verification: curl for list/filter/detail, UI checks.

If you’re ready, I’ll generate Block 2 in the same style—full paths, code, comments, Makefile targets, and curl verification.

---

## Questions to tailor this perfectly

1. **Package name:** Keep `co.ke.bluestron` or prefer a different root (e.g., `ke.bluestron`)?
2. **DB access:** Are you using local Postgres with `postgres` superuser, or should I include a Docker Compose for Postgres?
3. **Branding:** Do you want Tailwind added now for Bluestron’s visual polish, or keep minimal CSS until functionality is complete?
4. **Auth:** Should we defer authentication until after Courses/Registration, or include a simple admin login early?
5. **Email:** For registration confirmations, do you prefer SMTP (e.g., Gmail) or a transactional service later?

Say the word, and I’ll ship Block 2: Courses—fully implemented and verifiable.