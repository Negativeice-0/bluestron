## Bluestron scaffold with Spring Boot 3.5.9 (Maven), Next.js (TypeScript), Postgres, Tailwind

You’re asking for clean, opinionated, enterprise‑friendly scaffolding—minimal dependencies, strict TypeScript, reproducible DB commands, and end‑to‑end verification per dependent block. We’ll start with Categories (since Courses depend on them), then stack Courses next.

Your additional input doesn’t derail anything—it sharpens the constraints. The only trade‑off: strict TypeScript without `any`/`unknown` means we’ll be explicit with types and avoid runtime schema validators for now. Speed can wait; correctness and reproducibility lead.

---

## Assumptions and alignment

- **Spring Boot:** 3.5.9, **Maven**, Java 17.
- **DB:** Postgres already initialized; we’ll use raw SQL migrations with `IF NOT EXISTS`.
- **Config:** You provided `application.yml`—we’ll keep it intact and not override.
- **Frontend:** Next.js latest, App Router, strict TypeScript, Tailwind (defaults + Bluestron colors), `next/image` for images, SEO via metadata.
- **No Lombok, no Flyway** (minimal deps). We’ll keep migrations as SQL files executed via `Makefile`.
- **Monorepo:** `bluestron/` with `backend/` and `frontend/`.

---

## Project structure

```
bluestron/
├─ backend/
│  ├─ src/main/java/co/ke/bluestron/...
│  ├─ src/main/resources/application.yml
│  ├─ pom.xml
│  ├─ migrations/
│  │  ├─ 001_init_schema.sql
│  │  ├─ 002_categories_table.sql
│  │  └─ 003_seed_categories.sql
├─ frontend/
│  ├─ app/...
│  ├─ components/...
│  ├─ lib/...
│  ├─ public/...
│  ├─ tailwind.config.ts
│  ├─ postcss.config.js
│  ├─ package.json
│  ├─ tsconfig.json
│  ├─ next.config.ts
├─ Makefile
├─ README.md
```

---

## Backend (Maven, Spring Boot 3.5.9)

#### backend/pom.xml
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>co.ke.bluestron</groupId>
  <artifactId>bsapi</artifactId>
  <version>0.0.1</version>
  <name>bsapi</name>
  <description>Bluestron API</description>

  <properties>
    <java.version>17</java.version>
    <spring.boot.version>3.5.9</spring.boot.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring.boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <!-- Allegory: Keep the orchestra small—only the instruments we need. -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>42.7.3</version>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>
```

#### backend/src/main/resources/application.yml
```yaml
server:
  port: 8080

spring:
  application:
    name: bsapi
  datasource:
    url: jdbc:postgresql://localhost:5432/bsdb
    username: bsdbu
    password: bsdbp2Pass&1!
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format-sql: true
        jdbc:
          time-zone: UTC
    open-in-view: false

management:
  endpoints:
    web:
      exposure:
        include: health,mappings,info
  endpoint:
    health:
      show-details: when_authorized

logging:
  level:
    root: INFO
```

#### backend/src/main/java/co/ke/bluestron/BluestronApplication.java
```java
package co.ke.bluestron;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// Allegory: The conductor—starts the symphony and keeps tempo.
@SpringBootApplication
public class BluestronApplication {
    public static void main(String[] args) {
        SpringApplication.run(BluestronApplication.class, args);
    }
}
```

---

## Database migrations (raw SQL, IF NOT EXISTS)

#### backend/migrations/001_init_schema.sql
```sql
-- Allegory: Build the hall before placing shelves.
CREATE SCHEMA IF NOT EXISTS bluestron;
SET search_path TO bluestron;
```

#### backend/migrations/002_categories_table.sql
```sql
SET search_path TO bluestron;

-- Allegory: Shelves for categories—labeled and indexed.
CREATE TABLE IF NOT EXISTS categories (
  id          BIGSERIAL PRIMARY KEY,
  slug        TEXT UNIQUE NOT NULL,
  name        TEXT NOT NULL,
  description TEXT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_categories_slug ON categories(slug);
CREATE INDEX IF NOT EXISTS idx_categories_name ON categories(name);
```

#### backend/migrations/003_seed_categories.sql
```sql
SET search_path TO bluestron;

-- Allegory: Stock the shelves with familiar sections.
INSERT INTO categories (slug, name, description)
VALUES
  ('project-management-me', 'Project Management & M&E', 'PM, M&E, evaluations, USAID rules'),
  ('data-management-analysis', 'Data Management & Analysis', 'Excel, Power BI, SPSS, Stata, R, SAS, CSPro, cybersecurity'),
  ('gis-it', 'GIS & IT / Mobile Data Collection', 'GIS in M&E, spatial analysis, mobile data collection'),
  ('management-hr', 'Management & Administration / HR', 'HR planning, BPM, supervisory skills, communication'),
  ('climate-environment', 'Climate Change / Environment', 'Climate finance, ESG, environmental safeguards')
ON CONFLICT (slug) DO NOTHING;
```

---

## Backend domain, repository, service, controller

#### backend/src/main/java/co/ke/bluestron/categories/Category.java
```java
package co.ke.bluestron.categories;

import jakarta.persistence.*;
import java.time.OffsetDateTime;

// Allegory: A shelf record—simple, sturdy, timestamped.
@Entity
@Table(name = "categories", schema = "bluestron")
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String slug;

    @Column(nullable = false)
    private String name;

    @Column
    private String description;

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;

    @PrePersist
    public void onCreate() {
        OffsetDateTime now = OffsetDateTime.now();
        this.createdAt = now;
        this.updatedAt = now;
    }

    @PreUpdate
    public void onUpdate() {
        this.updatedAt = OffsetDateTime.now();
    }

    public Long getId() { return id; }
    public String getSlug() { return slug; }
    public void setSlug(String slug) { this.slug = slug; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public OffsetDateTime getCreatedAt() { return createdAt; }
    public OffsetDateTime getUpdatedAt() { return updatedAt; }
}
```

#### backend/src/main/java/co/ke/bluestron/categories/CategoryRepository.java
```java
package co.ke.bluestron.categories;

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

// Allegory: The librarian—finds shelves by label.
public interface CategoryRepository extends JpaRepository<Category, Long> {
    Optional<Category> findBySlug(String slug);
    boolean existsBySlug(String slug);
}
```

#### backend/src/main/java/co/ke/bluestron/categories/CategoryDTO.java
```java
package co.ke.bluestron.categories;

import jakarta.validation.constraints.NotBlank;

// Allegory: The index card—clean, minimal, validated.
public record CategoryDTO(
        @NotBlank String slug,
        @NotBlank String name,
        String description
) {}
```

#### backend/src/main/java/co/ke/bluestron/categories/CategoryResponse.java
```java
package co.ke.bluestron.categories;

// Allegory: The public label—what visitors read.
public record CategoryResponse(
        Long id,
        String slug,
        String name,
        String description
) {
    public static CategoryResponse from(Category c) {
        return new CategoryResponse(c.getId(), c.getSlug(), c.getName(), c.getDescription());
    }
}
```

#### backend/src/main/java/co/ke/bluestron/categories/CategoryService.java
```java
package co.ke.bluestron.categories;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

// Allegory: The curator—keeps shelves consistent.
@Service
public class CategoryService {

    private final CategoryRepository repo;

    public CategoryService(CategoryRepository repo) {
        this.repo = repo;
    }

    @Transactional(readOnly = true)
    public List<CategoryResponse> list() {
        return repo.findAll().stream().map(CategoryResponse::from).toList();
    }

    @Transactional
    public CategoryResponse create(CategoryDTO dto) {
        if (repo.existsBySlug(dto.slug())) {
            throw new IllegalArgumentException("Category slug already exists: " + dto.slug());
        }
        Category c = new Category();
        c.setSlug(dto.slug());
        c.setName(dto.name());
        c.setDescription(dto.description());
        Category saved = repo.save(c);
        return CategoryResponse.from(saved);
    }

    @Transactional(readOnly = true)
    public CategoryResponse getBySlug(String slug) {
        Category c = repo.findBySlug(slug).orElseThrow(() -> new IllegalArgumentException("Not found: " + slug));
        return CategoryResponse.from(c);
    }
}
```

#### backend/src/main/java/co/ke/bluestron/categories/CategoryController.java
```java
package co.ke.bluestron.categories;

import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

// Allegory: The front desk—welcomes requests, returns neat answers.
@RestController
@RequestMapping("/api/categories")
public class CategoryController {

    private final CategoryService service;

    public CategoryController(CategoryService service) {
        this.service = service;
    }

    @GetMapping
    public ResponseEntity<List<CategoryResponse>> list() {
        return ResponseEntity.ok(service.list());
    }

    @GetMapping("/{slug}")
    public ResponseEntity<CategoryResponse> get(@PathVariable String slug) {
        return ResponseEntity.ok(service.getBySlug(slug));
    }

    @PostMapping
    public ResponseEntity<CategoryResponse> create(@Valid @RequestBody CategoryDTO dto) {
        return ResponseEntity.ok(service.create(dto));
    }
}
```

---

## Makefile (DB commands, backend run, verification)

#### Makefile
```make
# Allegory: One baton—consistent cues, no guesswork.

DB_NAME=bsdb
DB_USER=bsdbu
DB_PASS=bsdbp2Pass&1!
DB_HOST=localhost
DB_PORT=5432

.PHONY: db-migrate db-seed backend-run backend-build verify-categories frontend-dev frontend-build

db-migrate:
	@echo "Applying schema and categories table"
	psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f backend/migrations/001_init_schema.sql
	psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f backend/migrations/002_categories_table.sql

db-seed:
	@echo "Seeding categories"
	psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f backend/migrations/003_seed_categories.sql

backend-run:
	cd backend && mvn spring-boot:run

backend-build:
	cd backend && mvn -q -DskipTests package

verify-categories:
	@echo "GET /api/categories"
	curl -s http://localhost:8080/api/categories | jq '.'
	@echo "GET /api/categories/project-management-me"
	curl -s http://localhost:8080/api/categories/project-management-me | jq '.'

frontend-dev:
	cd frontend && npm run dev

frontend-build:
	cd frontend && npm run build
```

> Note: Ensure your local `psql` can authenticate with `bsdbu`. If password prompt appears, set `PGPASSWORD=$(DB_PASS)` in your shell or `.env`.

---

## Frontend (Next.js, TypeScript, Tailwind with Bluestron colors)

#### frontend/package.json
```json
{
  "name": "bluestron-frontend",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.2.5",
    "react": "18.2.0",
    "react-dom": "18.2.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.30",
    "@types/react": "^18.2.66",
    "typescript": "^5.6.2",
    "eslint": "^8.57.0",
    "eslint-config-next": "^14.2.5",
    "tailwindcss": "^3.4.13",
    "postcss": "^8.4.41",
    "autoprefixer": "^10.4.20"
  }
}
```

#### frontend/tailwind.config.ts
```ts
import type { Config } from 'tailwindcss';

const config: Config = {
  content: ['./app/**/*.{ts,tsx}', './components/**/*.{ts,tsx}'],
  theme: {
    extend: {
      colors: {
        // Allegory: Bluestron palette—calm blues, confident accents.
        bluestron: {
          primary: '#0A4D8C',   // deep blue
          secondary: '#1E88E5', // bright blue
          accent: '#00C2FF',    // cyan accent
          dark: '#062B4F',
          light: '#E6F2FA'
        }
      }
    }
  },
  plugins: []
};

export default config;
```

#### frontend/postcss.config.js
```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
};
```

#### frontend/app/globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Allegory: A quiet canvas—let the content breathe. */
:root {
  color-scheme: light;
}
```

#### frontend/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": { "@/*": ["./*"] },
    "noImplicitAny": true,
    "noUncheckedIndexedAccess": true
  }
}
```

#### frontend/next.config.ts
```ts
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  reactStrictMode: true,
  images: {
    remotePatterns: [
      { protocol: 'https', hostname: '**' }
    ]
  }
};

export default nextConfig;
```

#### frontend/app/layout.tsx
```tsx
import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: 'Bluestron — Training, Research & Software Development',
  description: 'Professional Training, Research & Software Development in Data, M&E, Management',
  icons: [{ rel: 'icon', url: '/favicon.ico' }]
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  // Allegory: The frame—consistent chrome around every exhibit.
  return (
    <html lang="en">
      <body className="min-h-screen bg-bluestron.light text-bluestron.dark">
        <header className="border-b border-slate-200">
          <nav className="mx-auto max-w-5xl flex gap-6 p-4 text-sm">
            <a href="/" className="text-bluestron.primary font-semibold">Bluestron</a>
            <a href="/courses">Courses</a>
            <a href="/services">Services</a>
            <a href="/contact">Contact</a>
          </nav>
        </header>
        <main className="mx-auto max-w-5xl p-4">{children}</main>
        <footer className="mx-auto max-w-5xl p-4 border-t border-slate-200 text-xs">
          © Bluestron
        </footer>
      </body>
    </html>
  );
}
```

#### frontend/lib/api.ts
```ts
// Allegory: A polite courier—fetches data and returns typed parcels.
const BASE_URL: string = process.env.NEXT_PUBLIC_API_URL ?? 'http://localhost:8080';

export type Category = {
  id: number;
  slug: string;
  name: string;
  description: string | null;
};

async function getJson<T>(url: string): Promise<T> {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) {
    const message: string = `Request failed: ${res.status}`;
    throw new Error(message);
  }
  const data: unknown = await res.json();
  // We trust backend contract; assert type for strict TS without any/unknown usage in signatures.
  return data as T;
}

export async function fetchCategories(): Promise<Category[]> {
  return getJson<Category[]>(`${BASE_URL}/api/categories`);
}

export async function fetchCategory(slug: string): Promise<Category> {
  return getJson<Category>(`${BASE_URL}/api/categories/${encodeURIComponent(slug)}`);
}
```

#### frontend/app/page.tsx (Home)
```tsx
import Image from 'next/image';
import { fetchCategories } from '@/lib/api';

export default async function HomePage() {
  const categories = await fetchCategories();
  // Allegory: The foyer—quick glance at the wings of the museum.
  return (
    <section className="space-y-6">
      <div className="rounded-lg bg-white p-6 shadow-sm">
        <h1 className="text-2xl font-bold text-bluestron.primary">Bluestron Training</h1>
        <p className="mt-2 text-sm">
          Professional Training, Research & Software Development in Data, M&E, Management
        </p>
        <div className="mt-4">
          <Image
            src="https://images.unsplash.com/photo-1529333166437-7750a6dd5a70?w=1200&q=80"
            alt="Training"
            width={1200}
            height={400}
            className="h-48 w-full object-cover rounded-md"
            priority
          />
        </div>
      </div>

      <div>
        <h2 className="text-xl font-semibold">Categories</h2>
        <ul className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
          {categories.map((c) => (
            <li key={c.id} className="rounded-md border border-slate-200 bg-white p-4">
              <a
                href={`/courses?category=${encodeURIComponent(c.slug)}`}
                className="text-bluestron.secondary font-medium"
              >
                {c.name}
              </a>
              <p className="text-xs mt-1">{c.description ?? '—'}</p>
            </li>
          ))}
        </ul>
      </div>
    </section>
  );
}
```

#### frontend/app/courses/page.tsx
```tsx
import { fetchCategories } from '@/lib/api';

type Params = { category?: string };

export default async function CoursesPage({ searchParams }: { searchParams?: Params }) {
  const categories = await fetchCategories();
  const selected: string | undefined = searchParams?.category;

  // Allegory: The catalog room—filters left, listings right (courses next block).
  return (
    <div className="grid grid-cols-1 md:grid-cols-[240px_1fr] gap-6">
      <aside className="space-y-2">
        <h3 className="font-semibold">Categories</h3>
        <ul className="space-y-1">
          {categories.map((c) => (
            <li key={c.id}>
              <a
                href={`/courses?category=${encodeURIComponent(c.slug)}`}
                className="text-sm text-bluestron.primary hover:underline"
              >
                {c.name}
              </a>
            </li>
          ))}
        </ul>
      </aside>
      <section>
        <h2 className="text-lg font-semibold">Courses</h2>
        {!selected ? (
          <p className="text-sm">Select a category to view courses.</p>
        ) : (
          <p className="text-sm">
            Selected category: <strong>{selected}</strong> — courses will appear here in Block 2.
          </p>
        )}
      </section>
    </div>
  );
}
```

#### frontend/components/CategoryBadge.tsx
```tsx
export function CategoryBadge({ name }: { name: string }) {
  // Allegory: A neat label—small, readable, clickable.
  return (
    <span className="inline-block rounded-full border border-slate-300 px-2 py-1 text-xs">
      {name}
    </span>
  );
}
```

---

## Verification loop (Categories)

1. **Apply migrations and seed:**
   ```
   make db-migrate
   make db-seed
   ```

2. **Run backend:**
   ```
   cd backend && mvn spring-boot:run
   ```

3. **Verify via curl:**
   ```
   make verify-categories
   # or
   curl -s http://localhost:8080/api/categories | jq '.'
   curl -s http://localhost:8080/api/categories/project-management-me | jq '.'
   ```

4. **Run frontend:**
   ```
   cd frontend && npm install
   make frontend-dev
   ```
   - Visit `http://localhost:3000` → Home shows categories.
   - Visit `http://localhost:3000/courses?category=project-management-me` → selection reflects.

5. **Create a new category (POST):**
   ```
   curl -X POST http://localhost:8080/api/categories \
     -H "Content-Type: application/json" \
     -d '{"slug":"test-category","name":"Test Category","description":"For verification"}'
   ```

---

## Next block preview: Courses (dependent on Categories)

We’ll add:
- `courses` table with FK to `categories(id)`, migrations + seed.
- Backend: `Course` entity, repository, DTOs, service, controller (`/api/courses`, filter by category).
- Frontend: Course listing under selected category, course detail page, register button.
- Verification: curl + UI.

---

## One honest question

- **Do you want Docker Compose for Postgres and the frontend/backend, or keep local services for now?** It’s optional; we can add it later without breaking the current flow.

If you’re good with this foundation, I’ll ship Block 2—Courses—fully implemented and verifiable, keeping the same discipline and Bluestron palette.